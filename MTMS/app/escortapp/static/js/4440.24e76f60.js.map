{"version":3,"file":"static/js/4440.24e76f60.js","mappings":"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","sources":["webpack://app/./node_modules/echarts/lib/chart/helper/Symbol.js","webpack://app/./node_modules/echarts/lib/chart/helper/SymbolDraw.js","webpack://app/./node_modules/echarts/lib/chart/helper/labelHelper.js","webpack://app/./node_modules/echarts/lib/chart/line.js","webpack://app/./node_modules/echarts/lib/chart/line/LineSeries.js","webpack://app/./node_modules/echarts/lib/chart/line/LineView.js","webpack://app/./node_modules/echarts/lib/chart/line/lineAnimationDiff.js","webpack://app/./node_modules/echarts/lib/chart/line/poly.js","webpack://app/./node_modules/echarts/lib/component/axis.js","webpack://app/./node_modules/echarts/lib/component/axis/CartesianAxisView.js","webpack://app/./node_modules/echarts/lib/component/gridSimple.js","webpack://app/./node_modules/echarts/lib/coord/axisDefault.js","webpack://app/./node_modules/echarts/lib/coord/axisModelCreator.js","webpack://app/./node_modules/echarts/lib/coord/cartesian/Axis2D.js","webpack://app/./node_modules/echarts/lib/coord/cartesian/AxisModel.js","webpack://app/./node_modules/echarts/lib/coord/cartesian/Cartesian.js","webpack://app/./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js","webpack://app/./node_modules/echarts/lib/coord/cartesian/Grid.js","webpack://app/./node_modules/echarts/lib/coord/cartesian/GridModel.js","webpack://app/./node_modules/echarts/lib/layout/points.js","webpack://app/./node_modules/echarts/lib/processor/dataSample.js","webpack://app/./node_modules/echarts/lib/visual/symbol.js"],"sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar findLabelValueDim = _labelHelper.findLabelValueDim;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle', 'normal'];\nvar emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\nvar normalLabelAccessPath = ['label', 'normal'];\nvar emphasisLabelAccessPath = ['label', 'emphasis'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  var valueDim = !useNameLabel && findLabelValueDim(data);\n\n  if (useNameLabel || valueDim != null) {\n    graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n      labelFetcher: seriesModel,\n      labelDataIndex: idx,\n      defaultText: useNameLabel ? data.getName(idx) : data.get(valueDim, idx),\n      isRectText: true,\n      autoColor: color\n    });\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, idx, isIgnore) {\n  var point = data.getItemLayout(idx); // Is an object\n  // if (point && point.hasOwnProperty('point')) {\n  //     point = point.point;\n  // }\n\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx)) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Array.<boolean>} [isIgnore]\n */\n\n\nsymbolDrawProto.updateData = function (data, isIgnore) {\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = {\n    itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label.normal'),\n    hoverLabelModel: seriesModel.getModel('label.emphasis'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data;\n\n  if (data) {\n    if (enableAnimation) {\n      data.eachItemGraphicEl(function (el) {\n        el.fadeOut(function () {\n          group.remove(el);\n        });\n      });\n    } else {\n      group.removeAll();\n    }\n  }\n};\n\nvar _default = SymbolDraw;\nmodule.exports = _default;","var _model = require(\"../../util/model\");\n\nvar otherDimToDataDim = _model.otherDimToDataDim;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction findLabelValueDim(data) {\n  var valueDim;\n  var labelDims = otherDimToDataDim(data, 'label');\n\n  if (labelDims.length) {\n    valueDim = labelDims[0];\n  } else {\n    // Get last value dim\n    var dimensions = data.dimensions.slice();\n    var dataType;\n\n    while (dimensions.length && (valueDim = dimensions.pop(), dataType = data.getDimensionInfo(valueDim).type, dataType === 'ordinal' || dataType === 'time')) {} // jshint ignore:line\n\n  }\n\n  return valueDim;\n}\n\nexports.findLabelValueDim = findLabelValueDim;","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerVisual(zrUtil.curry(visualSymbol, 'line', 'circle', 'line'));\necharts.registerLayout(zrUtil.curry(layoutPoints, 'line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(dataSample, 'line'));","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      normal: {\n        position: 'top'\n      }\n    },\n    // itemStyle: {\n    //     normal: {},\n    //     emphasis: {}\n    // },\n    lineStyle: {\n      normal: {\n        width: 2,\n        type: 'solid'\n      }\n    },\n    // areaStyle: {},\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.3 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n\nfunction sign(val) {\n  return val >= 0 ? 1 : -1;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Array.<Array.<number>>} points\n * @private\n */\n\n\nfunction getStackedOnPoints(coordSys, data) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = 0;\n\n  if (!baseAxis.onZero) {\n    var extent = valueAxis.scale.getExtent();\n\n    if (extent[0] > 0) {\n      // Both positive\n      valueStart = extent[0];\n    } else if (extent[1] < 0) {\n      // Both negative\n      valueStart = extent[1];\n    } // If is one positive, and one negative, onZero shall be true\n\n  }\n\n  var valueDim = valueAxis.dim;\n  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n  return data.mapArray([valueDim], function (val, idx) {\n    var stackedOnSameSign;\n    var stackedOn = data.stackedOn; // Find first stacked value with same sign\n\n    while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {\n      stackedOnSameSign = stackedOn;\n      break;\n    }\n\n    var stackedData = [];\n    stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n    stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n    return coordSys.dataToPoint(stackedData);\n  }, true);\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.normal.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    // Can only be x or y\n    if (visualMetaList[i].dimension < 2) {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta || coordSys.type !== 'cartesian2d') {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var dimension = visualMeta.dimension;\n  var dimName = data.dimensions[dimension];\n  var axis = coordSys.getAxis(dimName); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[dimName] = minCoord;\n  gradient[dimName + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n    var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n    var points = data.mapArray(data.getItemLayout, true);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var stackedOnPoints = getStackedOnPoints(coordSys, data);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      } // Update clipPath\n\n\n      lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, isSymbolIgnore); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOn = data.stackedOn;\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOn) {\n        var stackedOnSeries = stackedOn.hostModel;\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;","// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\nfunction sign(val) {\n  return val >= 0 ? 1 : -1;\n}\n\nfunction getStackedOnPoint(coordSys, data, idx) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];\n  var valueDim = valueAxis.dim;\n  var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n  var stackedOnSameSign;\n  var stackedOn = data.stackedOn;\n  var val = data.get(valueDim, idx); // Find first stacked value with same sign\n\n  while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {\n    stackedOnSameSign = stackedOn;\n    break;\n  }\n\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n  stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n  return coordSys.dataToPoint(stackedData);\n} // function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\n\n\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var dims = newCoordSys.dimensions;\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;","require(\"../coord/cartesian/AxisModel\");\n\nrequire(\"./axis/CartesianAxisView\");","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"./cartesianAxisHelper\");\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./axis\");\n\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  // \n  z: 0,\n  // \n  // \n  inverse: false,\n  // \n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // degree\n  nameRotate: null,\n  // Adapt to axis rotate, when nameLocation is 'middle'.\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // \n  nameTextStyle: {},\n  // \n  nameGap: 15,\n  silent: false,\n  // Default false to support tooltip.\n  triggerEvent: false,\n  // Default false to avoid legacy user event listener fail.\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  // \n  axisLine: {\n    // show\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    // lineStyle\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // \n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  // \n  axisTick: {\n    // show\n    show: true,\n    // grid\n    inside: false,\n    // length\n    length: 5,\n    // lineStyle\n    lineStyle: {\n      width: 1\n    }\n  },\n  // axis.axisLabel\n  axisLabel: {\n    show: true,\n    // grid\n    inside: false,\n    rotate: 0,\n    showMinLabel: null,\n    // true | false | null (auto)\n    showMaxLabel: null,\n    // true | false | null (auto)\n    margin: 8,\n    // formatter: null,\n    // TEXTSTYLE\n    fontSize: 12\n  },\n  // \n  splitLine: {\n    // show\n    show: true,\n    // lineStylelineStyle\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  // \n  splitArea: {\n    // show\n    show: false,\n    // areaStyleareaStyle\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // \n  boundaryGap: true,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  // \n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  // axis.axisLabel\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // \n  boundaryGap: [0, 0],\n  // ,  'dataMin' \n  // min: null,\n  //  'dataMax' \n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // 0_min_max\n  // scale: false,\n  // 5\n  splitNumber: 5 // Minimum interval\n  // minInterval: null\n  // maxInterval: null\n\n}, defaultOption); // FIXME\n\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"./axisDefault\");\n\nvar ComponentModel = require(\"../model/Component\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * If axis is on the zero position of the other axis\n   * @type {boolean}\n   */\n  onZero: false,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * If label is ignored.\n   * Automatically used when axis is category and label can not be all shown\n   * @param  {number}  idx\n   * @return {boolean}\n   */\n  isLabelIgnored: function (idx) {\n    if (this.type === 'category') {\n      var labelInterval = this.getLabelInterval();\n      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n    }\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Cartesian = require(\"./Cartesian\");\n\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nrequire(\"./GridModel\");\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;","require(\"./AxisModel\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\n// Grid \n//  Cartesian2D \nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;","function _default(seriesType, ecModel) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (!coordSys) {\n      return;\n    }\n\n    var dims = [];\n    var coordDims = coordSys.dimensions;\n\n    for (var i = 0; i < coordDims.length; i++) {\n      dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);\n    }\n\n    if (dims.length === 1) {\n      data.each(dims[0], function (x, idx) {\n        // Also {Array.<number>}, not undefined to avoid if...else... statement\n        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n      });\n    } else if (dims.length === 2) {\n      data.each(dims, function (x, y, idx) {\n        // Also {Array.<number>}, not undefined to avoid if...else... statement\n        data.setItemLayout(idx, isNaN(x) || isNaN(y) ? [NaN, NaN] : coordSys.dataToPoint([x, y]));\n      }, true);\n    }\n  });\n}\n\nmodule.exports = _default;","var samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType, ecModel, api) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var sampling = seriesModel.get('sampling');\n    var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n    if (coordSys.type === 'cartesian2d' && sampling) {\n      var baseAxis = coordSys.getBaseAxis();\n      var valueAxis = coordSys.getOtherAxis(baseAxis);\n      var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n      var size = extent[1] - extent[0];\n      var rate = Math.round(data.count() / size);\n\n      if (rate > 1) {\n        var sampler;\n\n        if (typeof sampling === 'string') {\n          sampler = samplers[sampling];\n        } else if (typeof sampling === 'function') {\n          sampler = sampling;\n        }\n\n        if (sampler) {\n          data = data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler);\n          seriesModel.setData(data);\n        }\n      }\n    }\n  }, this);\n}\n\nmodule.exports = _default;","function _default(seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n    var symbolSize = seriesModel.get('symbolSize');\n    data.setVisual({\n      legendSymbol: legendSymbol || symbolType,\n      symbol: symbolType,\n      symbolSize: symbolSize\n    }); // Only visible series has each data be visual encoded\n\n    if (!ecModel.isSeriesFiltered(seriesModel)) {\n      if (typeof symbolSize === 'function') {\n        data.each(function (idx) {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        });\n      }\n\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var itemSymbolType = itemModel.getShallow('symbol', true);\n        var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n        if (itemSymbolType != null) {\n          data.setItemVisual(idx, 'symbol', itemSymbolType);\n        }\n\n        if (itemSymbolSize != null) {\n          // PENDING Transform symbolSize ?\n          data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = _default;"],"names":["zrUtil","require","_symbol","createSymbol","graphic","_number","parsePercent","_labelHelper","findLabelValueDim","getSymbolSize","data","idx","symbolSize","getItemVisual","Array","slice","getScale","SymbolClz","seriesScope","Group","call","this","updateData","symbolProto","prototype","driftSymbol","dx","dy","parent","drift","_createSymbol","symbolType","removeAll","color","symbolPath","attr","z2","culling","scale","_symbolType","add","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","trigger","downplay","setZ","zlevel","z","setDraggable","draggable","cursor","silent","seriesModel","hostModel","isInit","updateProps","_updateCommon","fadeIn","target","style","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","type","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","labelModel","hoverLabelModel","hoverAnimation","cursorStyle","hasItemOption","itemModel","getItemModel","getModel","getItemStyle","getShallow","extend","elStyle","Math","PI","setColor","symbolInnerColor","setStyle","useNameLabel","valueDim","setLabelStyle","labelFetcher","labelDataIndex","defaultText","getName","get","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","ratio","animateTo","max","onNormal","on","fadeOut","cb","opt","keepLabel","text","dataIndex","inherits","_default","module","exports","SymbolDraw","symbolCtor","group","_symbolCtor","symbolDrawProto","symbolNeedsDraw","isIgnore","point","getItemLayout","isNaN","oldData","_data","SymbolCtor","diff","newIdx","symbolEl","setItemGraphicEl","update","oldIdx","getItemGraphicEl","position","remove","el","execute","updateLayout","eachItemGraphicEl","enableAnimation","_model","otherDimToDataDim","labelDims","length","dataType","dimensions","pop","getDimensionInfo","echarts","visualSymbol","layoutPoints","dataSample","registerVisual","curry","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","_config","createListFromArray","__DEV__","SeriesModel","dependencies","getInitialData","option","ecModel","defaultOption","coordinateSystem","legendHoverLink","clipOverflow","label","normal","lineStyle","width","step","smooth","smoothMonotone","symbol","showSymbol","showAllSymbol","connectNulls","sampling","animationEasing","progressive","hoverLayerThreshold","Infinity","lineAnimationDiff","modelUtil","_poly","Polyline","Polygon","ChartView","isPointsSame","points1","points2","i","p1","p2","getSmooth","getAxisExtentWithGap","axis","extent","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","sign","val","getStackedOnPoints","coordSys","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","onZero","getExtent","dim","baseDataOffset","mapArray","stackedOnSameSign","stackedOn","stackedData","dataToPoint","createGridClipShape","cartesian","hasAnimation","xExtent","getAxis","yExtent","isHorizontal","x","min","y","height","lineWidth","expandSize","clipPath","Rect","shape","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","Sector","cx","cy","r0","r","startAngle","endAngle","clockwise","inverse","createClipShape","turnPointsIntoStep","points","stepTurnAt","baseIndex","stepPoints","nextPt","pt","push","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","count","visualMeta","dimension","dimName","colorStops","map","stops","stop","coord","toGlobalCoord","dataToCoord","value","stopLen","outerColors","reverse","tinyExtent","minCoord","maxCoord","coordSpan","each","offset","unshift","gradient","LinearGradient","init","lineGroup","symbolDraw","_symbolDraw","_lineGroup","render","api","getData","lineStyleModel","areaStyleModel","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","setClipPath","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","defaults","getLineStyle","fill","stroke","lineJoin","stackedOnSmooth","getAreaStyle","stackedOnSeries","dispose","payload","queryDataIndex","ignore","categoryAxis","getAxesByScale","isLabelIgnored","bind","current","stackedOnCurrent","next","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","getStackedOnPoint","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","dims","diffItem","pointAdded","currentPt","getRawIndex","rawIndex","sort","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","Path","vec2","fixClipWithShadow","vec2Min","vec2Max","scaleAndAdd","v2Copy","copy","v","cp0","cp1","isPointNull","p","drawSegment","ctx","start","segLen","allLen","smoothMin","smoothMax","prevIdx","k","nextIdx","nextP","ratioNextSeg","prevP","lenPrevSeg","lenNextSeg","sub","abs","dist","bezierCurveTo","lineTo","getBoundingBox","smoothConstraint","ptMin","ptMax","brush","buildPath","len","result","bbox","stackedOnBBox","closePath","AxisBuilder","AxisView","cartesianAxisHelper","ifIgnoreOnTick","getInterval","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","axisPointerClass","axisModel","oldAxisGroup","_axisGroup","gridModel","getCoordSysModel","layout","axisBuilder","getGroup","name","labelInterval","groupTransition","superCall","_splitLine","isBlank","splitLineModel","lineColors","lineInterval","isArray","gridRect","getRect","lineCount","ticksCoords","getTicksCoords","ticks","getTicks","showMinLabel","showMaxLabel","tickCoord","colorIndex","Line","subPixelOptimizeLine","anid","x1","y1","x2","y2","_splitArea","splitAreaModel","areaColors","prevX","prevY","areaInterval","areaStyle","extendComponentView","registerPreprocessor","xAxis","yAxis","grid","show","nameLocation","nameRotate","nameTruncate","maxWidth","ellipsis","placeholder","nameTextStyle","nameGap","triggerEvent","tooltip","axisPointer","axisLine","onZeroAxisIndex","axisTick","inside","axisLabel","rotate","margin","fontSize","splitLine","splitArea","axisDefault","merge","boundaryGap","alignWithLabel","interval","splitNumber","timeAxis","logAxis","logBase","ComponentModel","_layout","getLayoutParams","mergeLayoutParam","AXIS_TYPES","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","axisType","mergeDefaultAndTheme","layoutMode","inputPositionParams","themeModel","getTheme","getDefaultOption","mergeAll","registerSubTypeDefaulter","Axis","Axis2D","coordExtent","constructor","index","model","asc","ret","getLabelInterval","getLabel","pointToData","clamp","coordToData","toLocalCoord","axisModelCreator","axisModelCommonMixin","AxisModel","superApply","arguments","resetRange","mergeOption","restoreData","queryComponents","mainType","gridIndex","id","gridId","getAxisType","axisDim","extraOption","dimAxisMapper","_axes","Cartesian","_dimList","getAxes","scaleType","toLowerCase","filter","addAxis","_dataCoordConvert","input","method","dimList","output","Cartesian2D","containPoint","axisX","axisY","contain","containData","BoundingRect","getLayoutRect","axisHelper","CoordinateSystem","ifAxisCrossZero","niceScaleExtent","isAxisUsedInTheGrid","rotateTextRect","textRect","rotateRadians","boundingBox","plain","beforeWidth","beforeHeight","afterWidth","cos","sin","afterHeight","rotatedRect","getLabelUnionRect","rect","labels","getFormattedLabels","axisLabelModel","labelCount","ceil","unrotatedSingleRect","getTextRect","singleRect","union","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","gridProto","fixAxisOnZero","axesMap","otherAxisDim","axes","hasOwnProperty","otherAxis","canNotOnZeroToAxis","updateAxisTransfrom","coordBase","axisExtent","axisExtentSum","axisPointerEnabled","_rect","_updateScale","resize","ignoreContainLabel","getBoxLayoutParams","getWidth","getHeight","axesList","adjustAxes","setExtent","labelUnionRect","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","key","isObject","coordList","getCartesians","convertToPixel","finder","_findConvertTarget","convertFromPixel","xAxisModel","getReferringComponents","yAxisModel","coordsList","indexOf","componentIndex","axisPositionUsed","left","right","top","bottom","axesCount","eachComponent","createAxisCreator","axisPosition","createScaleByModel","isCategory","unionExtent","coordDimToDataDim","unionExtentFromData","eachSeries","isCartesian2D","axesModels","findAxesModels","getTooltipAxes","baseAxes","otherAxes","axesTypes","create","grids","register","containLabel","backgroundColor","borderWidth","borderColor","seriesType","eachSeriesByType","coordDims","setItemLayout","NaN","samplers","average","frame","sum","nearest","indexSampler","round","sampler","size","rate","downSample","setData","defaultSymbolType","legendSymbol","eachRawSeriesByType","setVisual","isSeriesFiltered","rawValue","getRawValue","params","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize"],"sourceRoot":""}